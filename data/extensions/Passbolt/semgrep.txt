/home/codescan/passbolt_browser_extension/src/all/background_page/controller/sso/ssoAuthenticationController.test.js:124:26:warning(detect-non-literal-regexp):      fetch.doMockOnceIf(new RegExp(`/sso/${scenario.providerId}/login.json`), async req => {:RegExp() called with a `scenario` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.
/home/codescan/passbolt_browser_extension/src/all/background_page/controller/sso/ssoAuthenticationController.test.js:150:26:warning(detect-non-literal-regexp):      fetch.doMockOnceIf(new RegExp(`/sso/${scenario.providerId}/login.json`), async() => mockApiResponse(scenario.loginUrlResponse));:RegExp() called with a `scenario` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.
/home/codescan/passbolt_browser_extension/src/all/background_page/controller/sso/ssoAuthenticationController.test.js:175:26:warning(detect-non-literal-regexp):      fetch.doMockOnceIf(new RegExp(`/sso/${scenario.providerId}/login.json`), async() => mockApiResponseError(400));:RegExp() called with a `scenario` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.
/home/codescan/passbolt_browser_extension/src/all/background_page/controller/sso/ssoAuthenticationController.test.js:194:26:warning(detect-non-literal-regexp):      fetch.doMockOnceIf(new RegExp(`/sso/${scenario.providerId}/login.json`), async() => mockApiResponseError(400));:RegExp() called with a `scenario` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.
/home/codescan/passbolt_browser_extension/src/all/background_page/controller/sso/ssoAuthenticationController.test.js:220:26:warning(detect-non-literal-regexp):      fetch.doMockOnceIf(new RegExp(`/sso/${scenario.providerId}/login.json`), async() => mockApiResponseError(400));:RegExp() called with a `scenario` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.
/home/codescan/passbolt_browser_extension/src/all/background_page/controller/sso/ssoAuthenticationController.test.js:253:26:warning(detect-non-literal-regexp):      fetch.doMockOnceIf(new RegExp(`/sso/${scenario.providerId}/login.json`), async() => mockApiResponse(scenario.loginUrlResponse));:RegExp() called with a `scenario` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.
/home/codescan/passbolt_browser_extension/src/all/background_page/controller/sso/ssoAuthenticationController.test.js:276:26:warning(detect-non-literal-regexp):      fetch.doMockOnceIf(new RegExp(`/sso/${scenario.providerId}/login.json`), async() => mockApiResponse(scenario.loginUrlResponse));:RegExp() called with a `scenario` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.
/home/codescan/passbolt_browser_extension/src/all/background_page/controller/sso/ssoAuthenticationController.test.js:299:26:warning(detect-non-literal-regexp):      fetch.doMockOnceIf(new RegExp(`/sso/${scenario.providerId}/login.json`), async() => mockApiResponse(scenario.loginUrlResponse));:RegExp() called with a `scenario` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.
/home/codescan/passbolt_browser_extension/src/all/background_page/controller/sso/ssoAuthenticationController.test.js:323:26:warning(detect-non-literal-regexp):      fetch.doMockOnceIf(new RegExp(`/sso/${scenario.providerId}/login.json`), async() => mockApiResponse(scenario.loginUrlResponse));:RegExp() called with a `scenario` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.
/home/codescan/passbolt_browser_extension/src/all/background_page/controller/sso/ssoAuthenticationController.test.js:341:26:warning(detect-non-literal-regexp):      fetch.doMockOnceIf(new RegExp(`/sso/${scenario.providerId}/login.json`), async() => mockApiResponseError(403, "Wrong CSRF token"));:RegExp() called with a `scenario` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.
/home/codescan/passbolt_browser_extension/src/all/background_page/model/entity/account/accountEntity.test.data.js:37:10:warning(insecure-object-assign):  data = Object.assign(defaultData, data);:Depending on the context, user control data in `Object.assign` can cause web response to include data that it should not have or can lead to a mass assignment vulnerability.
/home/codescan/passbolt_browser_extension/src/all/background_page/model/entity/account/accountEntity.test.data.js:42:10:warning(insecure-object-assign):  return Object.assign(defaultData, data);:Depending on the context, user control data in `Object.assign` can cause web response to include data that it should not have or can lead to a mass assignment vulnerability.
/home/codescan/passbolt_browser_extension/src/all/background_page/model/entity/accountRecovery/accountRecoveryPrivateKeyPasswordDecryptedDataEntity.test.data.js:24:17:error(detected-generic-secret):    private_key_secret: "f7cf1fa06f973a9ecbb5f0e2bc6d1830532e53ad50da231036bd6c8c00dd7c7dc6c07b04004615cd6808bea2cb6a4ce4c46f7f36b8865292c0f7a28cd6f56112",:Generic Secret detected
/home/codescan/passbolt_browser_extension/src/all/background_page/model/entity/actionLog/defaultActionLog.test.js:23:12:warning(insecure-object-assign):    return Object.assign(dto, changes);:Depending on the context, user control data in `Object.assign` can cause web response to include data that it should not have or can lead to a mass assignment vulnerability.
/home/codescan/passbolt_browser_extension/src/all/background_page/model/entity/folder/external/externalFoldersCollection.js:263:21:warning(detect-non-literal-regexp):      const regex = new RegExp(`^${escapedPath}($|\/)`);:RegExp() called with a `path` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.
/home/codescan/passbolt_browser_extension/src/all/background_page/model/entity/mfa/mfaSetupTotpEntity.test.data.js:17:107:error(detected-generic-secret):    otpProvisioningUri: "otpauth://totp/www.passbolt.local:admin%40passbolt.com?issuer=www.passbolt.local&secret=TVWEGQFS3WPCID6GYAPHHCC54VXHFUL7EC5FVHEMVH7CKQI2XEQQ&algorithm=SHA1&digits=6&period=30",:Generic Secret detected
/home/codescan/passbolt_browser_extension/src/all/background_page/model/entity/mfa/mfaSetupTotpEntity.test.data.js:25:107:error(detected-generic-secret):    otpProvisioningUri: "otpauth://totp/www.passbolt.local:admin%40passbolt.com?issuer=www.passbolt.local&secret=TVWEGQFS3WPCID6GYAPHHCC54VXHFUL7EC5FVHEMVH7CKQI2XEQQ&algorithm=sha1&digits=6&period=30",:Generic Secret detected
/home/codescan/passbolt_browser_extension/src/all/background_page/model/entity/resource/external/externalResourcesCollection.js:178:21:warning(detect-non-literal-regexp):      const regex = new RegExp(`^${escapedPath}\/`);:RegExp() called with a `path` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.
/home/codescan/passbolt_browser_extension/src/all/background_page/model/entity/totp/totpEntity.test.js:73:105:error(detected-generic-secret):    const url = new URL('otpauth://totp/pro.passbolt.local:admin@passbolt.com?issuer=pro.passbolt.local&secret=OFL3VF3OU4BZP45D4ZME6KTF654JRSSO4Q2EO6FJFGPKHRHYSVJA');:Generic Secret detected
/home/codescan/passbolt_browser_extension/src/all/background_page/model/keyring.js:28:25:error(detected-pgp-private-key-block):const PRIVATE_HEADER = '-----BEGIN PGP PRIVATE KEY BLOCK-----';:Something that looks like a PGP private key block is detected. This is a potential hardcoded secret that could be leaked if this code is committed. Instead, remove this code block from the commit.
/home/codescan/passbolt_browser_extension/src/all/background_page/model/request.js:39:3:error(remote-property-injection):  fetchOptions.headers[key] = value;:Bracket object notation with user input is present, this might allow an attacker to access all properties of the object and even it's prototype. Use literal values for object properties.
/home/codescan/passbolt_browser_extension/src/all/background_page/service/secret/pownedService.js:35:20:warning(jssha-sha1):    const shaObj = new jsSHA('SHA-1', 'TEXT');:The SHA1 hashing algorithm is considered to be weak. If this is used in any sensitive operation such as password hashing, or is used to ensure data integrity (collision sensitive) then you should use a stronger hashing algorithm. For passwords, consider using `Argon2id`, `scrypt`, or `bcrypt`. For data integrity, consider using `SHA-256`.
/home/codescan/passbolt_browser_extension/src/all/background_page/utils/format/string.js:631:7:error(insecure-document-method):      div.innerHTML = `${s} `;:User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities
/home/codescan/passbolt_browser_extension/src/all/background_page/utils/format/string.js:967:14:warning(detect-non-literal-regexp):  const re = new RegExp(goog.string.regExpEscape(ss), '');:RegExp() called with a `ss` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.
/home/codescan/passbolt_browser_extension/src/all/background_page/utils/format/string.js:980:14:warning(detect-non-literal-regexp):  const re = new RegExp(goog.string.regExpEscape(ss), 'g');:RegExp() called with a `ss` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.
/home/codescan/passbolt_browser_extension/src/all/background_page/utils/format/string.js:1301:18:warning(detect-non-literal-regexp):  const regexp = new RegExp(`(^${delimiters})([a-z])`, 'g');:RegExp() called with a `opt_delimiters` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.
/home/codescan/passbolt_browser_extension/src/all/background_page/utils/uuid.js:40:20:warning(jssha-sha1):    const shaObj = new jsSHA('SHA-1', 'TEXT');:The SHA1 hashing algorithm is considered to be weak. If this is used in any sensitive operation such as password hashing, or is used to ensure data integrity (collision sensitive) then you should use a stronger hashing algorithm. For passwords, consider using `Argon2id`, `scrypt`, or `bcrypt`. For data integrity, consider using `SHA-256`.
